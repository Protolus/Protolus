var GLOBAL_ITEMS = function(){
    var items = [];
    for (var key in this) items.push(key);
    return items;
}();

(function(){
/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- XHTMLParser
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(!Array.copy){
    Array.implement({
        copy : function() {
            var result = [];
            this.each(function(item){
                result.push(item);
            }.bind(this));
            return result;
        }
    });
}

if(!Array.sumStrings){
    Array.implement({
        sumStrings : function(){
            var result = 0;
            this.each(function(child){
                var val = parseInt(Number.from(child));
                if(val) result += val;
            });
            return result;
        }
    });
}

if(!Array.commonBase){
    Array.implement({
        commonBase : function(legalTerminals){ //todo: support callback
            if(legalTerminals && typeOf(legalTerminals) == 'string') legalTerminals = [legalTerminals];
            var directories = this.clone();
            if(directories.length == 0) throw('empty array has no base');
            var candidate = directories.pop();
            if(candidate.lastIndexOf('/') != -1) candidate = candidate.substring(0, candidate.lastIndexOf('/'));
            directories.each(function(directory){
                if(candidate == '') return;
                if(directory.indexOf(candidate) == -1 && legalTerminals.contains(candidate.substr(candidate.length-1, 1))) return;
                else candidate = candidate.substring(0, candidate.length-1);
            });
            return candidate;
        }
    });
}/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- XHTMLParser
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(!Element){
    //dummy DOM for server-side management
    var Element = new Class({
        children : [],
        attributes : {},
        initialize : function(name, options){
            this.tagName = name;
            this.attributes = options;
        },
        appendChild : function(element){
            this.children.push(element);
        },
        appendText : function(text){
            this.children.push(text);
        },
        getChildren : function(expression){
            if(expression.substring(0, 2) == '//'){
                var results = [];
                var val = expression.substring(2);
                this.traverse(function(node){
                    if( node.tagName == val ) results.push(node);
                });
            }
        }
    });
    Element.Events = {};
}

if(!Elements) var Elements = new Class({});
if(!NodeList) var NodeList = new Class({});

//todo: wrap with conditional
Element.Events.hashchange = {
    onAdd: function (){
        var hash = location.hash;
        var hashchange = function (){
            if (hash == location.hash) return;
            hash = location.hash;
            document.id(window).fireEvent('hashchange', hash.indexOf('#') == 0 ? hash.substr(1) : hash);
        };
        if ("onhashchange" in window) window.onhashchange = hashchange;
        else hashchange.periodical(50);
    }
};

if(!Element.diff){
    Element.implement({
        diff : function(node){
            //console.log(['diff', this, node]);
            this.childNodes.each(function(child, index){
                //console.log(['node comp', child.sameAs(node.childNodes[index])]);
            });
        }
    });
}

if(!Element.sameAs){
    Element.implement({
        sameAs : function(node, recursive){
            different = false;
            if(this.nodeName != node.nodeName) different = true;
            this.attributes.each(function(value, name){
                if(node[name] != value) different = true;
            });
            if(recursive){
                if(this.childNodes.length != node.childNodes.length) different = true;
                else this.childNodes.each(function(child, index){
                    if(!child.sameAs(node.childNodes[index])) different = true;
                });
            }
            return !different;
        }
    });
}

if(!Element.traverse){
    Element.implement({
        traverse : function(nodeFunction){
            nodeFunction(this);
            this.getChildren().each(function(child){
                child.traverse(nodeFunction);
            });
        }
    });
}

if(!Element.siblingsBefore){
    Element.implement({
        siblingsBefore : function(){
            var results = [];
            var found = false;
            this.getParent().getChildren().each(function(child){
                if(this == child) found = true;
                if(!found) results.push(child);
            });
            return new Elements(results);
        }
    });
}

if(!Element.siblingsAfter){
    Element.implement({
        siblingsAfter : function(){
            var results = [];
            var found = false;
            this.getParent().getChildren().each(function(child){
                if(found) results.push(child);
                if(this == child) found = true;
            });
            return new Elements(results);
        }
    });
}

if(!Element.aquiresStyle){
    Element.implement({
        aquiresStyle : function(name, callback){
            if(this.getStyle(name)){
                callback(this.getStyle(name));
            }else{
                this.aquiresStyle.delay(50, this, [name, callback]);
            }
        }
    });
}

if(!Element.removeElements){
    Element.implement({
        removeElements : function(elements){
            elements.each(function(element){
                if(this.contains(element)){
                    try{
                        this.removeChild(element);
                    }catch(ex){ //this means it's contained but not a direct child... recurse
                        this.getChildren().each(function(child){
                            document.id(child).removeElements(elements);
                        }.bind(this));
                    }
                }
            }.bind(this));
            return this;
        }
    });
}

if(!Element.iFrameContainsJSON){
    Element.implement({
        iFrameContainsJSON : function(callback){
            try{
                var data = JSON.decode(this.contentWindow.document.body.innerHTML);
                if(!data) throw('nope');
                try{
                    callback(data);
                }catch(ex2){
                    console.log(['error', ex2])
                }
            }catch(ex){
                this.iFrameContainsJSON.delay(50, this, [callback]);
            }
        }
    });
}

if(!Element.hasStyle){
    Element.implement({
        hasStyle : function(name, style){
            var result = false;
            var num = Number.from(this.getStyle(name));
            if(num != null){
                switch(style.substring(0,1)){
                    case '>' :
                        if(num > Number.from(style.substring(1))) result = true;
                        break;
                    case '<' :
                        if(num > Number.from(style.substring(1))) result = true;
                        break;
                    default:
                        if(num == Number.from(style)) result = true;
                }
            }else{
                switch(style.substring(0,1)){
                    case '>' :
                        if(this.getStyle(name) > style.substring(1)) result = true;
                        break;
                    case '<' :
                        if(this.getStyle(name) > style.substring(1)) result = true;
                        break;
                    default:
                        if(this.getStyle(name) == style) result = true;
                }
            }
            return result;
        }
    })
}

if(!Elements.mergedStyles){
    Elements.implement({
        mergedStyles : function(styles){
            results = [];
            if(typeOf(styles) == 'string'){
                styles = styles.split(',');
            }
            styles.each(function(style){
                results = results.concat(this.getStyle(style));
            }.bind(this));
            return results;
        }
    });
}

if(!Element.enlargeToFit){
    Element.implement({
        enlargeToFit : function(element, callback){
            if(this.dummy && this.src == this.dummy.src){
                this.resizeToFit();
                return;
            }
            this.dummy = new Image();
            if(!this.resizeToFit){
                this.resizeToFit = function(){
                    var theseDim = {x:this.dummy.width, y:this.dummy.height};
                    var thoseDim = element.getSize();
                    var aR = this.dummy.height/this.dummy.width;
                    var viewAR = thoseDim.y/thoseDim.x;
                    if(aR > 1){ //viewport orientation
                        if(aR < viewAR){ //blow up to fit hieght
                            this.setStyle('height', thoseDim.y);
                            this.setStyle('width', (aR)*thoseDim.y);
                        }else{ //blow up to fit width
                            this.setStyle('height', (aR)*thoseDim.x);
                            this.setStyle('width', thoseDim.x);
                        }
                    }else{
                        if(aR < viewAR){ //blow up to fit hieght
                            this.setStyle('height', thoseDim.y);
                            this.setStyle('width', (1/aR)*thoseDim.y);
                        }else{ //blow up to fit width
                            this.setStyle('height', (aR)*thoseDim.x);
                            this.setStyle('width', thoseDim.x);
                        }
                    }
                    if(callback) callback();
                }.bind(this);
                this.dummy.onload = this.resizeToFit;
            }
            this.dummy.src = this.src;

        }
    });
}

if(!Elements.excludeStyles){
    Elements.implement({
        excludeStyles : function(styles){
            var results = [];
            this.each(function(element){
                var found = false;
                Object.each(styles, function(style, name){
                    if(typeOf(style) == 'array'){
                        style.each(function(thisStyle){
                            found = found || element.hasStyle(name, thisStyle);
                        }.bind(this));
                    }else{
                        found = found || element.hasStyle(name, style);
                    }
                }.bind(this));
                if(!found) results.push(element);
            }.bind(this));
            return new Elements(results);
        }
    });
}

if(!Elements.includeStyles){
    Elements.implement({
        includeStyles : function(styles){
            results = [];
            this.each(function(element){
                var found = false;
                Object.each(styles, function(style, name){
                    if(typeOf(style) == 'array'){
                        style.each(function(thisStyle){
                            found = found || element.hasStyle(name, thisStyle);
                        }.bind(this));
                    }else{
                        found = found || element.hasStyle(name, style);
                    }
                }.bind(this));
                if(found) results.push(element);
            }.bind(this));
            return new Elements(results);
        }
    });
}

if(!Element.transitionIn){
    Element.implement({
        transitionIn : function(element, options, outgoingOptions){ //todo: support callback
            if(typeOf(element) == 'string') element = element.toDOM();
            if(!outgoingOptions) outgoingOptions = options; //todo: actually we want to invert the option values here... later
            element.setStyle('position', 'absolute');
            element.setStyle('opacity', 0);
            element.inject(this, 'before');
            this.fade('out');
            element.fade('in');
            element.setStyle('position', 'relative');
            this.dispose();
            return element[0];
        }
    });
}

if(!Element.linkText){
	Element.implement({
		linkText : function(element, fieldname, regex){
			if(!this.tagName.toLowerCase() == 'input') throw('invalid element');
			if(!fieldname) fieldname = 'html';
			var reactor = function(){
				var val = this.value;
				element = document.id(element);
				if(element){
					element.set(fieldname, val);
				}
			}.bind(this);
			this.addEvent('keydown', reactor);
			this.addEvent('keyup', reactor);
			this.addEvent('keypress', reactor);
		}
	});
}/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- XHTMLParser
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(!NodeList.prototype.each){
    NodeList.prototype.each = function(callback){
        for(index in this){
            callback(this[index], index);
        }
    }
}

if(!NodeList.prototype.indexOf){
    NodeList.prototype.indexOf = function(item){
        var result = -1;
        for(index in this){
            if(item === this[index]) result = index;
        }
        return result;
    }
}/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- XHTMLParser
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(!Function.actionTimeout) Function.actionTimeout = 16384;
if(!Function.whenTrue){
    Function.implement({
        whenTrue : function(actionFunction, args, delayFunction, timeoutFunction, timeout, counter){
            if(!timeout) timeout = Function.actionTimeout;
            if(!counter) counter = 0;
            if(!timeoutFunction) timeoutFunction = function(event){
                throw('Condition not met after '+event.time+'ms');
            };
            var result = this();
            if(!result){
                var delayTime = Math.pow(2, counter); // geometric falloff
                if(delayTime >= timeout){
                    timeoutFunction({
                        count : counter,
                        time : delayTime
                    });
                    return;
                }
                counter++;
                this.whenTrue.delay(delayTime, this, [actionFunction, args, delayFunction, timeoutFunction, timeout, counter]);
                if(delayFunction) delayFunction({
                    count : counter,
                    time : delayTime
                });
            }else{
                actionFunction.apply(this, args);
            }
        }
    });
}/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- XHTMLParser
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(!Number.isFloat){
    Number.implement({
        isFloat : function() {
            return /\./.test(this.toString());
        }
    });
}/*
---
description: A MooTools CSS loader

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
    core/1.2.4: '*'

provides: [Midas.CSSParser]
...
*/
if(!Midas) var Midas = {};
Midas.CSSParser = new Class({
    parse: function(text){
        var inStyle = false;
        var inComment = false;
        var inPredicate = false;
        var styleName = '';
        var definition = {selector:'', styles: {}};
        var ch;
        var result = [];
        for(var lcv=0; lcv < text.length; lcv++){
            ch = text[lcv];
            if(inComment){
                if(ch == '*' && text[lcv+1] == '/'){
                    inComment = false;
                    lcv++;
                }
                continue;
            }
            if(ch == '/' && text[lcv+1] == '*'){
                inComment = true;
                lcv++;
                continue;
            }
            if(inStyle){
                if(inPredicate){
                    if(ch == ';' || ch == '}'){
                        definition.styles[styleName] = definition.styles[styleName].trim();
                        inPredicate = false;
                        styleName = '';
                        if(ch == '}') {
                            result.push(definition);
                            inStyle = false;
                            definition = {selector:'', styles: []};
                        }
                    }else{
                        if(!definition.styles[styleName]) definition.styles[styleName] = ch;
                        else definition.styles[styleName] += ch;
                    }
                }else{
                    if(ch == ':'){
                        inPredicate = true;
                        styleName = styleName.trim();
                    }else if(ch == '}') {
                        result.push(definition);
                        inStyle = false;
                        definition = {selector:'', styles: {}};
                    }else{
                        styleName += ch;
                    }
                    
                }
                continue;
            }
            if(ch == '{'){
                definition.selector = definition.selector.trim()
                inStyle = true;
                continue;
            }
            definition.selector += ch;
        }
        return result;
    },
    apply : function(data){
        if(typeof data == 'string') data = this.parse(data);
        //console.log(data);
        data.each(function(definition){
            var elements = $$(definition.selector);
            elements.each(function(element){
                for(style in definition.styles) element.setStyle(style, definition.styles[style]);
            }.bind(this));
        }.bind(this));
    }
});/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- XHTMLParser
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(!Object.profile){
    Object.profile = function(object, deep, indent){
        switch(typeOf(object)){
            case 'element':
                return '[function]';
                break;
            case 'elements':
                return '[Element Collection]';
                break;
            case 'textnode':
                return '[text]';
                break;
            case 'whitespace':
                return '[whitespace]';
                break;
            case 'arguments':
                return '[arguments]';
                break;
            case 'array':
                break;
            case 'object':
                var results = '<table>'
                Object.each(object, function(field, name){
                    results += '<tr><td>'+name+'</td><td>'+Object.profile(field)+'</td></tr>'
                });
                results += '</table>';
                return results;
                break;
            case 'regexp':
                return '[RegExp]';
                break;
            case 'class':
                break;
                return '[Class]';
            case 'collection':
                return '[collection]';
                break;
            case 'window':
                return '[window]';
                break;
            case 'document':
                return '[document]';
                break;
            case 'event':
                return '[event]';
                break;
            case 'null':
                return 'NULL'
                break;
            case 'function':
                return '[function]';
                break;
            case 'string':
            case 'number':
            case 'date':
            case 'boolean':
            default :
                return ''+object;
        }
    }
}
/*

Object.expand(object, {
    'source.user_id' : 'user_id'
}, index);

//*/


if(!Object.expand){
    Object.expand = function(ob, fields, indices){ 
        Object.map(ob, function(value, key){
            if(typeOf(value) == 'object' && typeOf(value) == 'array'){
                //Object.traverse(value, fields, indices);
                Object.expand(value, fields, indices);
            }else{
                if(fields.contains(key) && indices[key] && indices[key][value]){
                    //inflate
                    if(key.endsWith('_id')){
                        key = key.substring(0, key.length-3);
                    }else{
                        key = key+'_object';
                    }
                    ob[key] = indices[key][value];
                }
            }
        }, this);
    }
}

/*if(!Object.watch){
    Object.implement({
        watch : function(property, callback, oldValue){
            if(!oldValue) oldValue = '';
            if(this[property] != oldValue){
                oldValue = this[property];
                callback(this[property]);
            }else this.watch.delay(5, this, [property, callback, oldValue]);
        }
    });
}*//*
---
description: A MooTools INI loader

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
    core/1.2.4: '*'

provides: [Midas.INIParser]
...
*/
if(!Midas) var Midas = {};
Midas.INIParser = new Class({
    parse: function(text){
        var inQuote = false;
        var inComment = false;
        var isAssigning = false;
        var inGrouping = false;
        var buffer = '';
        var label = '';
        var group = null;
        var currentQuoteType = '';
        var results = {};
        var ch;
        for(var lcv=0; lcv < text.length; lcv++){
            ch = text[lcv];
            if(buffer == '' && ch == '['){
                inGrouping = true;
            }
            if(inGrouping){
                if(ch == ']'){
                    group = buffer;
                    buffer = '';
                    inGrouping = false;
                }else if(ch != '[') buffer += ch;
                continue;
            }
            if(inComment){
                if(ch == "\n"){
                    inComment = false;
                    if(isAssigning){
                        if(group == null){
                            if(label != '') results[label] = buffer;
                        }else{
                            if(!results[group]) results[group] = {};
                            if(label != '') results[group][label] = buffer;
                        }
                        label = buffer = '';
                    }
                }else continue;
            }
            if(!inQuote && !inComment){ //we're reading chars
                if(ch == ';'){
                    inComment = true;
                    continue;
                }
                if(ch == '\'' || ch == '"'){
                    inQuote = true;
                    currentQuoteType = ch;
                    continue;
                }
                if(!isAssigning && ch == '='){
                    label = buffer;
                    buffer = '';
                    isAssigning = true;
                }else{
                    if(ch == "\n"){
                        isAssigning = false;
                        if(group == null){
                            if(label != '') results[label] = buffer;
                        }else{
                            if(!results[group]) results[group] = {};
                            if(label != '') results[group][label] = buffer;
                        }
                        label = buffer = '';
                    }else{
                        if(ch != ' ') buffer += ch;
                    }
                }
            }else{
                if(inQuote){ // keep reading until we see our quote end
                    if(ch == currentQuoteType){
                        inQuote = false;
                    }else{
                        buffer += ch;
                    }
                }
            }
        }
        if(group == null){
            if(label != '') results[label] = buffer;
        }else{
            if(!results[group]) results[group] = {};
            if(label != '') results[group][label] = buffer;
        }
        return results;
    }
});/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- Request
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(Request){
    Request.Pool = new Class({
        workers : [],
        successes : [],
        errors : [],
        data : {},
        initialize : function(requests, globalSuccess, globalError){
            requests.each(function(requestOptions){
                var request;
                if(requestOptions.onSuccess) requestOptions.successFunc = requestOptions.onSuccess;
                if(requestOptions.onFailure) requestOptions.failFunc = requestOptions.onFailure;
                requestOptions.onSuccess = function(data, xml){
                    if(requestOptions.successFunc) requestOptions.successFunc(data, xml);
                    if(requestOptions.id){
                        data.id = requestOptions.id;
                    }
                    this.successes.push(data);
                    if(!this.isWorking()){
                        if(this.completeWithNoErrors()){
                            globalSuccess(this.successes);
                        }else{
                            globalError(this.errors, this.successes);
                        }
                    }
                }.bind(this);
                requestOptions.onFailure = function(data){
                    if(requestOptions.failFunc) requestOptions.failFunc(data);
                    if(requestOptions.id){
                        data.id = requestOptions.id;
                    }
                    this.errors.push(data);
                    if(!this.isWorking()){
                        if(this.completeWithNoErrors()){
                            globalSuccess(this.successes);
                        }else{
                            globalError(this.errors, this.successes);
                        }
                    }
                }.bind(this);
                switch(requestOptions.objectType.toUpperCase()){
                    case 'IMAGE' :
                    case 'IMG' :
                        request = Asset.image(requestOptions.url, {
                            id: requestOptions.id,
                            title: requestOptions.title,
                            onload: requestOptions.onSuccess,
                            onerror: requestOptions.onFailure
                        });
                        break;
                    case 'CSS' :
                        request = Asset.css(requestOptions.url, {
                            id: requestOptions.id,
                            title: requestOptions.title,
                            onload: requestOptions.onSuccess,
                            onerror: requestOptions.onFailure
                        });
                        break;
                    case 'JAVASCRIPT' :
                    case 'JS' :
                        request = Asset.javascript(requestOptions.url, {
                            id: requestOptions.id,
                            title: requestOptions.title,
                            onload: requestOptions.onSuccess,
                            onerror: requestOptions.onFailure
                        });
                        break;
                    case 'JSON' :
                        request = new Request.JSON(requestOptions);
                        request.send();
                        break;
                    case 'HTML' : 
                        request = new Request.HTML(requestOptions);
                        request.send();
                        break;
                    default :
                        request = new Request(requestOptions);
                        request.send();
                }
                this.workers.push(request);
            }.bind(this));
        },
        isWorking :function(){
            return (this.workers.length != (this.successes.length + this.errors.length));
        },
        completeWithNoErrors :function(){
            return (this.workers.length == this.successes.length);
        }
    });
}if(!Midas) var Midas = {};
Midas.OrderedINIParser = new Class({
    parse: function(text, order){
        var inQuote = false;
        var inComment = false;
        var isAssigning = false;
        var inGrouping = false;
        var buffer = '';
        var label = '';
        var group = null;
        var currentQuoteType = '';
        var results = [];
        var ch;
        for(var lcv=0; lcv < text.length; lcv++){
            ch = text[lcv];
            if(buffer == '' && ch == '['){
                inGrouping = true;
            }
            if(inGrouping){
                if(ch == ']'){
                    group = buffer;
                    buffer = '';
                    inGrouping = false;
                }else if(ch != '[') buffer += ch;
                continue;
            }
            if(inComment){
                if(ch == "\n"){
                    inComment = false;
                    if(isAssigning){
                        if(group == null){
                            if(label != '') results[label] = buffer;
                        }else{
                            if(!results[group]) results[group] = {};
                            if(label != '') results[group][label] = buffer;
                        }
                        label = buffer = '';
                    }
                }else continue;
            }
            if(!inQuote && !inComment){ //we're reading chars
                if(ch == ';'){
                    inComment = true;
                    continue;
                }
                if(ch == '\'' || ch == '"'){
                    inQuote = true;
                    currentQuoteType = ch;
                    continue;
                }
                if(!isAssigning && ch == '='){
                    label = buffer;
                    buffer = '';
                    isAssigning = true;
                }else{
                    if(ch == "\n"){
                        isAssigning = false;
                        if(group == null){
                            if(label != '') results[results.length] = {key:label,value:buffer};
                        }else{
                            if(results.length == 0 || (results[results.length-1].key != group)) results[results.length] = {key:group,value:[]};
                            if(label != '') results[results.length-1]['value'][results[results.length-1]['value'].length] = {key:label, value:buffer};
                        }
                        label = buffer = '';
                    }else{
                        if(ch != ' ') buffer += ch;
                    }
                }
            }else{
                if(inQuote){ // keep reading until we see our quote end
                    if(ch == currentQuoteType){
                        inQuote = false;
                    }else{
                        buffer += ch;
                    }
                }
            }
        }
        if(group == null){
            if(label != ''){
                results[results.length] = {key:label,value:buffer};
            }
        }else{
            if(results.length == 0 || (results[results.length-1].key != group)) results[results.length] = {key:group,value:[]};
            if(label != '') results[results.length-1]['value'][results[results.length-1]['value'].length] = {key:label, value:buffer};
        }
        return results;
    }
});/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- Request
- Class

provides: [Request.Stable]

*/
if(Request){
    Request.Stable = new Class({
        worker : {},
        baseClass : null,
        initialize : function(options, baseClass){ //baseClass is experimental, do not use yet
            if(!baseClass) this.baseClass = Request;
            else this.baseClass = baseClass;
            var completed = false;
            options = this.wrap(options, 'onSuccess', this.complete.bind(this));
            options = this.wrap(options, 'onFailure', this.complete.bind(this));
            options = this.wrap(options, 'onError', this.complete.bind(this));
            Request.Stable.workers.each(function(worker){ //try to use the first inactive thread
                if(!worker.working && !completed){ //potential for thread collision
                    worker.working = true;
                    worker.slave = new this.baseClass(options);
                    worker.slave.send();
                    this.worker = worker;
                    completed = true;
                }
            }.bind(this));
            if(!completed){ //if we haven't already found a place to execute the job
                if(Request.Stable.workers.length < Request.Stable.workerSize){ //generate a thread if we have space for a new one
                    this.worker.slave = new this.baseClass(options);
                    this.worker.working = true;
                    Request.Stable.workers.push(this.worker);
                    this.worker.slave.send();
                }else{ //wait
                    Request.Stable.workQueue.push(options);
                }
            }
        },
        nextJob : function(){
            var job = Request.Stable.workQueue.pop();
            if(job){
                this.worker.slave = new this.baseClass(job);
                this.worker.working = false;
                this.worker.slave.send();
            } 
        },
        status : function(title){
            console.log(['S:'+title, {
                q : Request.Stable.workQueue.length,
                t : Request.Stable.workers.length,
                workers : Request.Stable.workers
            }]);
        },
        complete : function(){
            //if(!this.worker) console.log(['NW', this]);
            this.worker.working = false;
            this.nextJob();
            //this.status('complete');
        },
        wrap : function(obj, key, func){
            if(key in obj){
                var innerFunction = obj[key];
                var myFunction = func.bind(this);
                obj[key] = function(arg1, arg2){
                        myFunction(arg1, arg2);
                        innerFunction(arg1, arg2);
                }.bind(this);
            }else obj[key] = func;
            return obj;
        }
    });
    Request.Stable.workers = [];
    Request.Stable.workQueue = [];
    Request.Stable.workerSize = 6;
}/*
---
description: A properties parser and simple properties abstraction

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
    core/1.2.4: '*'

provides: [Midas.Properties,Midas.PropertiesParser]
...
*/
if(!Midas) var Midas = {};
Midas.Properties = new Class({
    values : {},
    parser : null,
    initialize: function(filename, callback){
        if(filename){
            new Request({
                url: filename,
                onSuccess: function(data) {
                    this.load(data);
                    if(callback) callback();
                }.bind(this)
            }).send();
        }
        this.parser = new Midas.PropertiesParser();
    },
    set : function(label, value){
        this.values[label] = value;
    }, 
    get : function(label){
        return this.values[label];
    },
    load : function(data){
        this.values = this.parser.parse(data);
    },
    write : function(){
        result = '';
        for(label in this.values){
            result += label+' = '+this.values[label]+"\n";
        }
        return result;
    }
});
Midas.PropertiesParser = new Class({
    parse : function(fileBody){
        var lines = fileBody.split("\n");
        var pos, predicate, unicodeMatches;
        var properties = {};
        var multi = false;
        var last = null;
        lines.each(function(line){
            if(line.trim().substring(0,1) == '#' || line.trim().substring(0,1) == '!' ) return;
            if(multi && last != null){
                if(line.substring( line.length-1) != '\\'){
                    properties[last] = properties[last] + line.trim();
                    multi = false;
                }else{
                    properties[last] = properties[last] + line.trim().substring(0, line.length-1);
                }
                return;
            }
            pos = line.indexOf("=");
            if(pos == -1) pos = line.indexOf(":");
            if(pos != -1){
                last = line.substring(0, pos).trim().replace(/\\ /g, ' ');
                predicate = line.substring(pos+1).trim();
                unicodeMatches = predicate.match( /\\u[0-9]{4}/g );
                if(unicodeMatches) unicodeMatches.each(function(match){
                    var character = eval('"'+match+'"');
                    var rx = new RegExp(match.replace('\\', '\\\\'),'g');
                    predicate = predicate.replace(rx, character);
                });
                if(line.substring( line.length-1) == '\\'){
                    predicate = line.substring(pos+1).trim();
                    properties[last] = predicate.substring(0, predicate.length-1);
                    multi = true;
                }else{
                    properties[last] = predicate;
                }
            }
        });
        return properties;
    }
});/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- Class

provides: [Request]

*/
if(!Request){
    var Request = new Class({
        options : {
            url : '',
            method : 'GET',
            data : {},
            evalScripts : false,
            evalResponse : false,
            timeout : false,
            noCache : false,
            user : false,
            password : false,
            onRequest : false,
            onLoadStart : false,
            onProgress : false,
            onComplete : false,
            onCancel : false,
            onSuccess : false,
            onFailure : false,
            onException : false
        },
        initialize : function(){
        
        },
        send : function(){
            if(this.options.onRequest) this.options.onRequest(onRequest);
            if(this.options.onLoadStart) this.options.onLoadStart(onLoadStart);
            //TODO: WTF to do about progress?
            request({
                uri: this.options.url
            }, function (error, response, bodyText) {
                if(error){
                    //todo: create error object here
                    if(this.options.onException) this.options.onException(error);
                }else{
                    if(this.options.onSuccess) this.options.onSuccess(bodyText);
                }
                if(this.options.onComplete) this.options.onSuccess(onComplete);
            }.bind(this));
        },
        getHeader : function(){},
        setHeader : function(){},
        cancel : function(){},
    });
}/*
---
description: An extensible Mootools object container bridging to a pureJS SAX parser

license: [MIT-style, LGPL]

authors:
- Abbey Hawk Sparrow

requires:
    core/1.2.4: '*'

provides: [Midas.XMLParser]
...
*/
if(!Midas) var Midas = {};
Midas.SAXParser = new Class({
    initialize: function(){
        this.buildXMLcomponents();
    },
    buildXMLcomponents: function(){
        this.handler = new MidasSAXEventHandler();
        this.parser = new SAXDriver();
    },
    open: function(tagName, attributes){
        var node = document.id('widget_panel');
        //var pro = profile(attributes);
        var pro = attributes["d"];
        node.innerHTML = node.innerHTML + pro +"<br/><br/>";
    },
    content: function(text){
    },
    close: function(tagName){
    },
    error: function(exception){
        //console.log(['SAX Parse Error!', exception, exception.m_parser.m_xml.charAt(exception.m_parser.iP)+exception.m_parser.m_xml.charAt(exception.m_parser.iP+1)+exception.m_parser.m_xml.charAt(exception.m_parser.iP+2), exception.m_parser.m_xml]);
        throw('SAX Parse Error('+exception.m_strErrMsg+')');
    },
    parse: function(xml){
        if(!this.handler) this.buildXMLcomponents();
        this.handler.startTag = this.open.bind(this);
        this.handler.createError = this.error.bind(this);
        this.handler.endTag = this.close.bind(this);
        this.handler.charData = this.content.bind(this);
        this.parser.setDocumentHandler(this.handler);
        this.parser.setLexicalHandler(this.handler);
        this.parser.setErrorHandler(this.handler);
        this.parser.parse(xml);
    }
});
// SAX constructor
MidasSAXEventHandler = function() {
    this.characterData = "";
};
// My Non-exposed hooks (all existing hooks require fucking with char data internally, 
// so we call cleanly out to here to make truly pluggable functions)
MidasSAXEventHandler.prototype.startTag = function(name, attrs){};
MidasSAXEventHandler.prototype.charData = function(chars){};
MidasSAXEventHandler.prototype.endTag = function(name){};
//MidasSAXEventHandler Object SAX INTERFACES
MidasSAXEventHandler.prototype.characters = function(data, start, length) {
    this.characterData += data.substr(start, length);
}
MidasSAXEventHandler.prototype.endDocument = function() {
    this._handleCharacterData();
    //place endDocument event handling code below this line
}
MidasSAXEventHandler.prototype.endElement = function(name) {
    this._handleCharacterData();
    //place endElement event handling code below this line
    this.endTag(name);
}
MidasSAXEventHandler.prototype.processingInstruction = function(target, data) {
    this._handleCharacterData();
    //place processingInstruction event handling code below this line
}
MidasSAXEventHandler.prototype.setDocumentLocator = function(locator) {
    this._handleCharacterData();
    //place setDocumentLocator event handling code below this line
}
MidasSAXEventHandler.prototype.startElement = function(name, atts) {
    this._handleCharacterData();
    var attrs = {};
    //place startElement event handling code below this line
    for(var lcv =0; lcv < atts.getLength(); lcv++){
        attrs[atts.getName(lcv)] = atts.getValue(lcv);
    }
    this.startTag(name, attrs);
}
MidasSAXEventHandler.prototype.startDocument = function() {
    this._handleCharacterData();
    //place startDocument event handling code below this line
}
//MidasSAXEventHandler Object Lexical Handlers
MidasSAXEventHandler.prototype.comment = function(data, start, length) {
    this._handleCharacterData();
    //place comment event handling code below this line
}
MidasSAXEventHandler.prototype.endCDATA = function() {
    this._handleCharacterData();
    //place endCDATA event handling code below this line
}
MidasSAXEventHandler.prototype.startCDATA = function() {
    this._handleCharacterData();
    //place startCDATA event handling code below this line
}
// MidasSAXEventHandler Object Error Interface
MidasSAXEventHandler.prototype.error = function(exception) {
    this._handleCharacterData();
    //place error event handling code below this line
    this.createError(exception);
}
MidasSAXEventHandler.prototype.fatalError = function(exception) {
    this._handleCharacterData();
    //place fatalError event handling code below this line
    this.createError(exception);
}
MidasSAXEventHandler.prototype.warning = function(exception) {
    this._handleCharacterData();
    //place warning event handling code below this line
}
//MidasSAXEventHandler Object Internal Functions
MidasSAXEventHandler.prototype._fullCharacterDataReceived = function(fullCharacterData) {
    //place character (text) event handling code below this line
    this.charData(fullCharacterData);
}
MidasSAXEventHandler.prototype._handleCharacterData = function()  {
    if (this.characterData != ""){
        this._fullCharacterDataReceived(this.characterData);
    }
    this.characterData = "";
}/*
---
description: This is an asynchronous JS request pool for MooTools. Sometimes it's useful to fetch a bunch of resources in parallel, this plugin facilitates that.

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
- XHTMLParser
- Class
- Request.JSON
- Request.HTML
- Asset

provides: [Request.Stable]

*/
if(!String.whenIn){
    String.implement({
        whenIn : function(element, callback){
            (function(){
                return element.getElements(this.toString()).length > 0;
            }.bind(this)).whenTrue(function(){
                callback(element.getElements(this.toString())[0]);
            }.bind(this));
        }
    });
}
if(!String.whenFullIn){
    String.implement({
        whenFullIn : function(element, callback){
            (function(){
                var q = element.getElements(this.toString());
                return q.length > 0 && q[0].getChildren().length > 0;
            }.bind(this)).whenTrue(function(){
                callback(element.getElements(this.toString())[0]);
            }.bind(this));
        }
    });
}
if(!String.toDOM){
    String.implement({
        toDOM: function(mode) {
            if(!mode) mode = 'sax';
            var result = false;
            switch(mode){
                case 'sax':
                    //we're going to parse the HTML and build our own DOM off the page
                    var pageParser = new XHTMLParser();
                    return pageParser.parse(this);
                    break;
                case 'iframe':
                    var myIFrame = new IFrame({
                        src: 'about:blank',
                        id: 'dummy_iframe',
                    });
                    myIFrame.inject(document.body);
                    myIFrame.set('html', this);
                    result = myIFrame.clone();
                    myIFrame.destroy();
                    break;
                case 'div':
                    var injector = new Element('div', {
                        'html': this,
                        'styles': {
                            'position': 'absolute',
                            'left': -1000000
                        }
                    }).inject(document.body);
                    result = injector.getChildren();
                    injector.destroy();
                    break;
            }
            return result;
        }
    });
}
if(!String.startsWith){
    String.implement({
        startsWith : function(text) {
            return this.indexOf(text) == 0;
        }
    });
}

if(!String.endsWith){
    String.implement({
        endsWith : function(text) {
            return this.substr(text.length * -1) === text;
        }
    });
}

if(!String.reverse){
    String.implement({
        reverse : function(){
            splitext = this.split("");
            revertext = splitext.reverse();
            reversed = revertext.join("");
            return reversed;
        }
    });
}

if(!String.splitHonoringQuotes){
    String.implement({
        splitHonoringQuotes: function(delimiter, quotes) {
            if(quotes == undefined) quotes = ['\'', '"'];
            var results = [''];
            var inQuote = false;
            var quote = null;
            for(var lcv=0; lcv < this.length; lcv++){
                if(inQuote){
                    if(this[lcv] == quote){
                        inQuote = false;
                        //results[results.length-1] += this[lcv];
                        //results[results.length] = '';
                    }else{
                        results[results.length-1] += this.charAt(lcv);
                    }
                }else{
                    if(quotes.contains(this[lcv])){
                        quote = this[lcv];
                        //results[results.length-1] += this[lcv];
                        inQuote = true;
                    }else if(this[lcv] == delimiter){
                        results[results.length] = '';
                    }else{
                        results[results.length-1] += this.charAt(lcv);
                    }
                }
            }
            return results;
        }
    });
}

if(!String.distance){
    String.implement({
        distance : function(s2){
            // levenshtein code by: Carlos R. L. Rodrigues, Onno Marsman, Andrea Giammarchi, Brett Zamir, Alexander M Beedie, Kevin van Zonneveld
            if (this == s2)  return 0;
            var s1_len = this.length;
            var s2_len = s2.length;
            if (s1_len === 0) return s2_len;
            if (s2_len === 0) return s1_len;
            var split = false;                                       // IE hack
            try { split = !('0')[0]; } catch (e) { split = true; }   // IE hack
            var s1;
            if (split) { 
                s1 = this.split('');
                s2 = s2.split('');
            }else{
                s1 = this;
            }
            var v0 = new Array(s1_len + 1);
            var v1 = new Array(s1_len + 1);
            var s1_idx = 0,
                s2_idx = 0,
                cost = 0;
            for (s1_idx = 0; s1_idx < s1_len + 1; s1_idx++) {
                v0[s1_idx] = s1_idx;
            }
            var char_s1 = '',
                char_s2 = '';
            for (s2_idx = 1; s2_idx <= s2_len; s2_idx++) {
                v1[0] = s2_idx;
                char_s2 = s2[s2_idx - 1];
                for (s1_idx = 0; s1_idx < s1_len; s1_idx++) {
                    char_s1 = s1[s1_idx];
                    cost = (char_s1 == char_s2) ? 0 : 1;
                    var m_min = v0[s1_idx + 1] + 1;
                    var b = v1[s1_idx] + 1;
                    var c = v0[s1_idx] + cost;
                    if (b < m_min) m_min = b;
                    if (c < m_min) m_min = c;
                    v1[s1_idx + 1] = m_min;
                }
                var v_tmp = v0;
                v0 = v1;
                v1 = v_tmp;
            }
            return v0[s1_len];
        }
    });
}

if(!String.existsAsURL){
    if(!String.urlExistences) String.urlExistences = [];
    String.implement({
        existsAsURL : function(callback){
            if(String.urlExistences[this] === true || String.urlExistences[this] === false) return String.urlExistences[this]; //buffer
            if(callback){
                throw('callback not yet supported!');
                //todo: support callback
            }else{
                try{
                    var req = document.window.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();
                    if (!req) throw new Error('XMLHttpRequest not supported');
                    req.open('HEAD', this, false);
                    req.send(null);
                    if (req.status == 200){
                        String.urlExistences[this] = true;
                        return true;
                    }else{
                        String.urlExistences[this] = false;
                        return false;
                    }
                }catch(ex){
                    return false;
                }
            }
        }
    });
}

if(!String.whenInDOM){ // try to execute the function using the string as an id
    if(!String.defaultReplacementTimeout) String.defaultReplacementTimeout = 16384;
    String.implement({
        whenInDOM : function(callback, delayCallback, timeoutCallback, timeout, counter){
            if(!timeout) timeout = String.defaultReplacementTimeout;
            if(!counter) counter = 0;
            if(!timeoutCallback) timeoutCallback = function(event){
                throw('Element did not appear in DOM(\''+event.id+'\') after '+event.time+'ms');
            };
            if(!document.id(this)){
                //we want to get the DOM node when it appears so we're looking for a gradient falloff of intervals as it approaches timeout
                //if(!String.DOMQueryCounts[this]) String.DOMQueryCounts[this] = 0;
                var delayTime = Math.pow(2, counter);
                if(delayTime >= timeout){
                    timeoutCallback({
                        id : this,
                        count : counter, 
                        time : delayTime
                    });
                }
                counter++;
                this.whenInDOM.delay(delayTime, this, [callback, delayCallback, timeoutCallback, timeout, counter]);
                if(delayCallback) delayCallback({
                    count : counter, 
                    time : delayTime
                });
            }else{
                callback(document.id(this));
            }
        }
    });
}

if(!String.regexEncode){
    String.regexChars = ['\\', '&','^', '$', '*', '+', '?', '.', '(', ')', '|', '{', '}', '[', ']'];
    String.regexEncodeRegexObject = new RegExp('([\\'+String.regexChars.join('|\\')+'])', 'g');
    String.implement({
        regexEncode : function(){
            return this.replace(String.regexEncodeRegexObject, '\\$1');
        }
    });
}

if(!String.nl2br){
    String.implement({
        nl2br : function(){
            return this.replace(/\n/mg, '<br/>');
        }
    });
}

if( (!String.entityEncode) && (!String.entityDecode) ){
    String.entities = {};
    String.entities.byCode = { 38: '&amp;', 60: '&lt;', 62: '&gt;', 160: '&nbsp;', 161: '&iexcl;', 162: '&cent;', 163: '&pound;', 164: '&curren;', 165: '&yen;', 166: '&brvbar;', 167: '&sect;', 168: '&uml;', 169: '&copy;', 170: '&ordf;', 171: '&laquo;', 172: '&not;', 173: '&shy;', 174: '&reg;', 175: '&macr;', 176: '&deg;', 177: '&plusmn;', 178: '&sup2;', 179: '&sup3;', 180: '&acute;', 181: '&micro;', 182: '&para;', 183: '&middot;', 184: '&cedil;', 185: '&sup1;', 186: '&ordm;', 187: '&raquo;', 188: '&frac14;', 189: '&frac12;', 190: '&frac34;', 191: '&iquest;', 192: '&Agrave;', 193: '&Aacute;', 194: '&Acirc;', 195: '&Atilde;', 196: '&Auml;', 197: '&Aring;', 198: '&AElig;', 199: '&Ccedil;', 200: '&Egrave;', 201: '&Eacute;', 202: '&Ecirc;', 203: '&Euml;', 204: '&Igrave;', 205: '&Iacute;', 206: '&Icirc;', 207: '&Iuml;', 208: '&ETH;', 209: '&Ntilde;', 210: '&Ograve;', 211: '&Oacute;', 212: '&Ocirc;', 213: '&Otilde;', 214: '&Ouml;', 215: '&times;', 216: '&Oslash;', 217: '&Ugrave;', 218: '&Uacute;', 219: '&Ucirc;', 220: '&Uuml;', 221: '&Yacute;', 222: '&THORN;', 223: '&szlig;', 224: '&agrave;', 225: '&aacute;', 226: '&acirc;', 227: '&atilde;', 228: '&auml;', 229: '&aring;', 230: '&aelig;', 231: '&ccedil;', 232: '&egrave;', 233: '&eacute;', 234: '&ecirc;', 235: '&euml;', 236: '&igrave;', 237: '&iacute;', 238: '&icirc;', 239: '&iuml;', 240: '&eth;', 241: '&ntilde;', 242: '&ograve;', 243: '&oacute;', 244: '&ocirc;', 245: '&otilde;', 246: '&ouml;', 247: '&divide;', 248: '&oslash;', 249: '&ugrave;', 250: '&uacute;', 251: '&ucirc;', 252: '&uuml;', 253: '&yacute;', 254: '&thorn;', 255: '&yuml;', 264: '&#264;', 265: '&#265;', 338: '&OElig;', 339: '&oelig;', 352: '&Scaron;', 353: '&scaron;', 372: '&#372;', 373: '&#373;', 374: '&#374;', 375: '&#375;', 376: '&Yuml;', 402: '&fnof;', 710: '&circ;', 732: '&tilde;', 913: '&Alpha;', 914: '&Beta;', 915: '&Gamma;', 916: '&Delta;', 917: '&Epsilon;', 918: '&Zeta;', 919: '&Eta;', 920: '&Theta;', 921: '&Iota;', 922: '&Kappa;', 923: '&Lambda;', 924: '&Mu;', 925: '&Nu;', 926: '&Xi;', 927: '&Omicron;', 928: '&Pi;', 929: '&Rho;', 931: '&Sigma;', 932: '&Tau;', 933: '&Upsilon;', 934: '&Phi;', 935: '&Chi;', 936: '&Psi;', 937: '&Omega;', 945: '&alpha;', 946: '&beta;', 947: '&gamma;', 948: '&delta;', 949: '&epsilon;', 950: '&zeta;', 951: '&eta;', 952: '&theta;', 953: '&iota;', 954: '&kappa;', 955: '&lambda;', 956: '&mu;', 957: '&nu;', 958: '&xi;', 959: '&omicron;', 960: '&pi;', 961: '&rho;', 962: '&sigmaf;', 963: '&sigma;', 964: '&tau;', 965: '&upsilon;', 966: '&phi;', 967: '&chi;', 968: '&psi;', 969: '&omega;', 977: '&thetasym;', 978: '&upsih;', 982: '&piv;', 8194: '&ensp;', 8195: '&emsp;', 8201: '&thinsp;', 8204: '&zwnj;', 8205: '&zwj;', 8206: '&lrm;', 8207: '&rlm;', 8211: '&ndash;', 8212: '&mdash;', 8216: '&lsquo;', 8217: '&rsquo;', 8218: '&sbquo;', 8220: '&ldquo;', 8221: '&rdquo;', 8222: '&bdquo;', 8224: '&dagger;', 8225: '&Dagger;', 8226: '&bull;', 8230: '&hellip;', 8240: '&permil;', 8242: '&prime;', 8243: '&Prime;', 8249: '&lsaquo;', 8250: '&rsaquo;', 8254: '&oline;', 8260: '&frasl;', 8364: '&euro;', 8472: '&weierp;', 8465: '&image;', 8476: '&real;', 8482: '&trade;', 8501: '&alefsym;', 8592: '&larr;', 8593: '&uarr;', 8594: '&rarr;', 8595: '&darr;', 8596: '&harr;', 8629: '&crarr;', 8656: '&lArr;', 8657: '&uArr;', 8658: '&rArr;', 8659: '&dArr;', 8660: '&hArr;', 8704: '&forall;', 8706: '&part;', 8707: '&exist;', 8709: '&empty;', 8711: '&nabla;', 8712: '&isin;', 8713: '&notin;', 8715: '&ni;', 8719: '&prod;', 8721: '&sum;', 8722: '&minus;', 8727: '&lowast;', 8729: '&#8729;', 8730: '&radic;', 8733: '&prop;', 8734: '&infin;', 8736: '&ang;', 8743: '&and;', 8744: '&or;', 8745: '&cap;', 8746: '&cup;', 8747: '&int;', 8756: '&there4;', 8764: '&sim;', 8773: '&cong;', 8776: '&asymp;', 8800: '&ne;', 8801: '&equiv;', 8804: '&le;', 8805: '&ge;', 8834: '&sub;', 8835: '&sup;', 8836: '&nsub;', 8838: '&sube;', 8839: '&supe;', 8853: '&oplus;', 8855: '&otimes;', 8869: '&perp;', 8901: '&sdot;', 8968: '&lceil;', 8969: '&rceil;', 8970: '&lfloor;', 8971: '&rfloor;', 9001: '&lang;', 9002: '&rang;', 9642: '&#9642;', 9643: '&#9643;', 9674: '&loz;', 9702: '&#9702;', 9824: '&spades;', 9827: '&clubs;', 9829: '&hearts;', 9830: '&diams;' };
    String.entities.byName = {};
    Object.each(String.entities.byCode, function(entity, code){ String.entities.byName[entity] = code; });
    var charSelectorString = '('+Object.keys(String.entities.byCode).map( function(code){ return String.fromCharCode(code).regexEncode() }, this).join('|')+')';
    String.entities.charSelector = new RegExp( charSelectorString, 'g' );
    var entitySelectorString = '('+Object.keys(String.entities.byName).map(function(entity){ return entity.regexEncode() }, this).join('|')+')';
    String.entities.entitySelector = new RegExp( entitySelectorString, 'gi');
    String.implement({
        entityEncode : function(){
            return this.replace(
                String.entities.charSelector,
                function(str, chr) {
                    return String.entities.byCode[chr.charCodeAt()];
                }
            );
        },
        entityDecode : function(){
            return this.replace(
                String.entities.entitySelector,
                function(str, entity) {
                    return String.fromCharCode(String.entities.byName[entity]);
                }
            );
        }
    });
}/*
---
description: A MooTools SASS parser, applier and converter

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
    core/1.2.4: '*'

provides: [Midas.SCSSParser]
...
*/
if(!Midas) var Midas = {};
Midas.SASSFunctions = {
    hsl : function(hue, saturation, lightness){
    
    },
    darken : function(color, percent){
        if(percent.endsWith('%')) percent = percent.substring(0, percent.length-1);
        if(color.startsWith('#')) color = color.substring(1);
        //console.log([color, percent]);
        var colors = [parseInt("0x"+color.substring(0,2)), parseInt("0x"+color.substring(2,4)), parseInt("0x"+color.substring(4,6))];
        colors[0] = Math.floor(colors[0] * ((100-percent)/100));
        colors[1] = Math.floor(colors[1] * ((100-percent)/100));
        colors[2] = Math.floor(colors[2] * ((100-percent)/100));
        //console.log(colors);
        return '#'+colors[0].toString(16).toUpperCase()+colors[1].toString(16).toUpperCase()+colors[2].toString(16).toUpperCase();
    },
    greyscale : function(color){
        if(percent.endsWith('%')) percent = percent.substring(0, percent.length-1);
        if(color.startsWith('#')) color = color.substring(1);
        //console.log([color, percent]);
        var colors = [parseInt("0x"+color.substring(0,2)), parseInt("0x"+color.substring(2,4)), parseInt("0x"+color.substring(4,6))];
        var val = (colors[0]+colors[1]+colors[3] == 0)?0:(colors[0]+colors[1]+colors[3])/3
        colors[0] = val;
        colors[1] = val;
        colors[2] = val;
        //console.log(colors);
        return '#'+colors[0].toString(16).toUpperCase()+colors[1].toString(16).toUpperCase()+colors[2].toString(16).toUpperCase();
    }
};
Midas.SCSS = function(){
    window.addEvent('domready', function() {
        var scssStyles = $$('head style[@type="text/scss"]');
        scssStyles.each(function(style){
            var sassParser = new Midas.SCSSParser();
            var css = sassParser.convertScssToCss(style.innerText);
            var convertedTag = new Element('style', {type: 'text/css'});
            convertedTag.innerHTML = css;
            convertedTag.inject(style, 'before');
        });
    });
}
//Midas.SCSS();
Midas.SCSSParser = new Class({
    parse: function(text){
        var inComment = false;
        var inPredicate = false;
        var identifier = '';
        var predicate = '';
        var ch;
        var definitions = [];
        var root = [];
        definitions.push(root);
        var node;
        for(var lcv=0; lcv < text.length; lcv++){
            ch = text[lcv];
            if(inComment){
                if(ch == '*' && text[lcv+1] == '/'){
                    inComment = false;
                    lcv++;
                }
                continue;
            }
            if(ch == '/' && text[lcv+1] == '*'){
                inComment = true;
                lcv++;
                continue;
            }
            if(inPredicate){
                if(ch == '{'){ //compound property
                    var newChild = [];
                    definitions.getLast().push({
                        property: identifier.trim(),
                        properties : newChild
                    });
                    definitions.push(newChild);
                    identifier = predicate = '';
                    inPredicate = false;
                    continue;
                }
                if(ch == ';' || ch == '}'){
                    definitions.getLast().push({
                        property: identifier,
                        value : predicate.trim()
                    });
                    inPredicate = false;
                    identifier = predicate = '';
                    if(ch == '}') definitions.pop();
                }else{
                    predicate += ch;
                }
                continue;
            }else{
                switch(ch){
                    case ':':
                        inPredicate = true;
                        identifier = identifier.trim();
                        break;
                    case '}':
                        definitions.pop();
                        identifier = predicate = '';
                        break;
                    case ';':
                        definitions.getLast().push({
                            directive: identifier.trim()
                        });
                        inPredicate = false;
                        identifier = predicate = '';
                        break;
                    case '{':
                        identifier = identifier.trim();
                        var newChild = [];
                            definitions.getLast().push({
                                selector: identifier,
                                styles : newChild
                            });
                        definitions.push(newChild);
                        identifier = predicate = '';
                        break;
                    default:
                        identifier += ch;
                }
                continue;
            }
        }
        return root;
    },
    convertScssPropsToCss : function(prefix, properties){
        var results = [];
        properties.each(function(property){
            if(property.value){
                results.push(prefix+'-'+property.property+':'+this.interpretValue(property.value));
            }else{
                this.convertScssPropsToCss(prefix+'-'+property.property, property.properties).append(results);
            }
        }.bind(this));
        return results;
    },
    interpretValue: function(value){
        var orig =  value;
        //replace any variable references we find in both the environment and a property (some vars are from mixins)
        var variableOccurances = value.match(/\$[A-Za-z][A-Za-z0-9_-]*/g);
        if(variableOccurances !== null) variableOccurances.each(function(match){
            if(match.startsWith('$')) match = match.substring(1);
            if(this.environment[match]){
                value = value.replace(new RegExp('\\$'+match), this.environment[match]);
            }
        }.bind(this));
        //now let's do any math we find
        var unitsExpression = /(px|em)/gi
        var level2_ops = value.match(/([0-9]+(?:px|em)? +[*\/] +[0-9]+(?:px|em)?)/gi);
        if(level2_ops !== null) level2_ops.each(function(op){
            var units = op.match(unitsExpression);
            var newVal = eval(op.replace(unitsExpression, ''))+'';
            newVal += (units.length > 0)?units[0]:'';
            value = value.replace(op, newVal);
        });
        var level1_ops = value.match(/([0-9]+(?:px|em)? +[-\+] +[0-9]+(?:px|em)?)/gi);
        if(level1_ops !== null) level1_ops.each(function(op){
            var units = op.match(unitsExpression);
            var newVal = eval(op.replace(unitsExpression, ''))+'';
            newVal += (units.length > 0)?units[0]:'';
            value = value.replace(op, newVal);
        });
        //now let's support functions
        var vals = value.match(/^([A-Za-z][A-Za-z0-9_-]*)\((.*)\)/);
        if(vals !== null && vals.length == 3 && Midas.SASSFunctions[vals[1]]){
            var args = vals[2].split(',');
            args.each(function(value, index){
                args[index] = value.trim();
            });
            var ret = Midas.SASSFunctions[vals[1]].apply( this, args );
            value = value.replace(vals[0], ret);
        }
        //if(orig != value) console.log([orig, ' ===> ', value]);
        return value;
    },
    environment : {_mixins:[]},
    extensions : {},
    mixin: function(name){
        result = false;
        this.environment['_mixins'].each(function(mixin){
            if(mixin.name == name) result = mixin;
        }.bind(this));
        return result;
    },
    extend: function(name, styles, base){
        if(!base){
            if(!this.extensions[name]) return;
            base = this.extensions[name];
        }
        var extender;
        var extendable = [];
        styles.each(function(style){
            if(style.style == name){
                extender = style;
            }
            if(style.style.startsWith(base)){
                extendable.push(style);
            }
        }.bind(this));
        styles.erase(extender);
        extendable.each(function(style){
            styles.push({style:style.style.replace(base, name), properties:style.properties.clone().append(extender.properties)})
        });
    },
    convertScssNodesToCss : function(nodes, parentSelector, results, environment){
        var selector = '';
        if(!parentSelector) parentSelector = '';
        else selector = parentSelector;
        if(!results) results = [];
        nodes.each(function(node){
            if(node.property){
                if(node.properties){
                    var props = this.convertScssPropsToCss(node.property, node.properties);
                    if(results.getLast() != null && results.getLast().style == selector){
                        props.append(results.getLast().properties);
                    }else{
                        results.push({style:selector, properties: props});
                    }
                }else{
                    if(selector.trim() == ''){
                        if(node.property.startsWith('$')) node.property = node.property.substring(1);
                        this.environment[node.property] = this.interpretValue(node.value);
                        return;
                    }
                    if(results.getLast() != null && results.getLast().style == selector){
                        results.getLast().properties.push(node.property+':'+this.interpretValue(node.value));
                    }else{
                        results.push({style:selector, properties: [node.property+':'+this.interpretValue(node.value)]});
                    }
                }
            }else if(node.directive){
                if(node.directive.startsWith('@include ')){
                    var pieces = node.directive.match(/@include ([A-Za-z][A-Za-z0-9_-]*)(\(.*\))?/);
                    var args = (pieces[2])? pieces[2].substring(1, pieces[2].length-1).split(',') : [];
                    args.each(function(value, index){
                        args[index] = value.trim();
                    });
                    var mixin;
                    if(mixin = this.mixin(pieces[1])){
                        args.each(function(value, index){
                            this.environment[mixin['_args'][index]] = value;
                        }.bind(this));
                        this.convertScssNodesToCss(mixin.styles, (selector).trim(), results);
                    }
                }
                if(node.directive.startsWith('@extend ')){
                    var baseStyle = node.directive.substring(8).trim();
                    this.extensions[selector] = baseStyle;
                }
            }else{
                if(node.selector.startsWith('@mixin ')){
                    var pieces = node.selector.match(/@mixin ([A-Za-z][A-Za-z0-9_-]*)(\(.*\))?/);
                    var name = pieces[1];
                    var args = pieces[2]?pieces[2].substring(1, pieces[2].length-1).split(','):[];
                    args.each(function(value, index){
                        if(value.startsWith('$')) args[index] = value.substring(1).trim();
                        else args[index] = value.trim();
                    });
                    node['_args'] = args;
                    node.name = name;
                    this.environment['_mixins'].push(node);
                    return;
                }
                if(node.selector.indexOf(',') == -1){
                    this.convertScssNodesToCss(node.styles, (selector+' '+node.selector).trim(), results);
                    this.extend((selector+' '+node.selector).trim(), results);
                }else{
                    node.selector.split(',').each(function(select){
                        this.convertScssNodesToCss(node.styles, (selector+' '+select.trim()).trim(), results);
                        this.extend((selector+' '+select).trim(), results);
                    }.bind(this));
                }
            }
        }.bind(this));
        return results;
    },
    convertScssToCss : function(data){
        if(typeof data == 'string') data = this.parse(data);
        var styles = this.convertScssNodesToCss(data);
        results = '';
        styles.each(function(style){
            results += style.style+'{'+"\n";
            style.properties.each(function(property){
                results += '   '+property+";\n";
            });
            results += '}'+"\n";
        }.bind(this));
        return results;
    }
});/*
---
description: An extensible Smarty Parser in Mootools

license: MIT-style

authors:
- Abbey Hawk Sparrow

requires:
    core/1.2.4: '*'

provides: [Midas.Smarty]
...
*/
if(!Midas) var Midas = {};
Midas.Smarty = new Class({
    //I am just going to do this my own way, my attempt at doing Smarty the way the smarty team does it left me wanting for death
    macroRegistry: {},
    template_directory : '',
    environment : {},
    internal : {},
    properties : {},
    blocks : [],
    config : {},
    debug : false,
    caching : true,
    runtimeCache : {},
    database : null,
    cacheID : null,
    initialize : function(options){
        if(!options) options = {};
        if(options.template_directory) this.template_directory = options.template_directory;
        //this.macroRegistry['panel'] = Midas.SmartyLib.renderPanel;
        this.macroRegistry['rdelim'] = function(panelName, attributes, smartyInstance, block){ return '}' };
        this.macroRegistry['ldelim'] = function(panelName, attributes, smartyInstance, block){ return '{' };
        this.macroRegistry['foreach'] = function(panelName, attributes, smartyInstance, block){
            return Midas.SmartyLib.forMacro(block.tag, smartyInstance, block)
        };
        this.macroRegistry['assign'] = function(panelName, attributes, smartyInstance, block){
            var value = Midas.SmartyLib.evaluateSmartyPHPHybridExpression(attributes['value'], smartyInstance);
            smartyInstance.set(attributes['var'], value );
        };
        this.macroRegistry['if'] = function(panelName, attributes, smartyInstance, block){
            return Midas.SmartyLib.ifMacro(block.tag, block.attrs, smartyInstance, block)
        };
        this.macroRegistry['/if'] = function(panelName, attributes, smartyInstance, block){ return ''; };
        this.macroRegistry['/foreach'] = function(panelName, attributes, smartyInstance, block){ return ''; };
        this.macroRegistry[''] = function(panelName, attributes, smartyInstance, block){ return ''; };
        this.macroRegistry['value'] = function(panelName, attributes, smartyInstance, block){
            var value = Midas.SmartyLib.evaluateSmartyPHPHybridExpression(block.content, smartyInstance);
            return value;
        };
        this.cacheID = Midas.SmartyLib.generateUUID();
        //if (this.caching) 
        //this.database = openDatabase('SmartyDB', "1.0", "Smarty Client Database", 200000);
        //this.database = new Database('SmartyDB'); 
    },
    seekVariable: function(accessor, rootNode, value){
        var name = accessor.trim();
        if(name.substr(0,9) == '$smarty.' ) name = name.substr(8);
        if(name.substr(0,8) == 'smarty.' ) name = name.substr(7);
        if(name.substr(0,1) == '$' ) name = name.substr(1);
        var keys = name.split('.');
        keys = keys.reverse();
        var nextIndex = keys.pop();
        if(rootNode[nextIndex] == undefined && keys.length > 0) rootNode[nextIndex] = {}; 
        var current = rootNode[nextIndex];
        var expression = 'rootNode[\''+nextIndex+'\']';
        var accessor = 'rootNode.'+nextIndex;
        while(keys.length > 0){
            nextIndex = keys.pop();
            expression += '[\''+nextIndex+'\']';
            if(isNaN(parseFloat(nextIndex))) accessor += '.'+nextIndex;
            else accessor += '['+nextIndex+']';
            var res = false;
            try{
                eval('if(!'+accessor+'){ res = true;}');
            }catch(error){ 
                //console.log(['error', error, accessor]); 
            }if(res && keys.length > 0){
                eval(accessor+' = {};') //if we aren't initialized, let's do that
            }
        }
        if((value ||value === 0) && value != undefined){
            if(this.debug) Midas.SmartyLib.output(expression+' <= '+value);
            eval(expression+' = value;');
            //if(value === null) eval('delete '+expression+';');
        }else{
            var value = eval(expression);
            if(this.debug) Midas.SmartyLib.output(expression+' => '+value);
            return value;
        }

    },
    //the disconnect in naming between the following two functions is insanity, sorry to pass on bad convention
    getTemplateVars : function(name){
        return this.get_template_vars(name);
    },
    get_template_vars : function(name){
        return this.get(name);
    },
    assign : function(name, value){
        return this.set(name, value);
    },
    set : function(name, value){
        //if(value == undefined) return false; //this should throw an error
        //if(name == null) return false;
        //console.log(['set', name, value]);
        var val = this.seekVariable(name, this.environment, value);
    },
    get : function(name){
            try{
                var val = this.seekVariable(name, this.environment);
                if(val != undefined) return val;
                else return '';
            }catch(exception){
                return '';
            }
    },
    getConfig : function(name){
        return this.seekVariable(name, this.config);
    },
    setConfig : function(name, value){
        return this.seekVariable(name, this.config, value);
    },
    getProperty : function(name){
        
    },
    output : function(value){
        return Midas.SmartyLib.output(value);
    },
    macro : function(name, attrs, block){
        //console.log(['MACRO', name]);
        //this.output(profile(attrs));
        if(!attrs.get) attrs.get = function(tagName){
            var value = null;
            this.each(function(item, index){
                if(item.name == tagName) value = item.value;
            }.bind(this));
            return value;
        }
        //console.log(this.macroRegistry[name]);
        if(this.macroRegistry[name]) return this.macroRegistry[name](attrs.get('name'), attrs, this, block);
        else return '<!-- '+name+' [Macro not found!] -->';
    },
    getTemplate : function(name, callback, immediate){
        if(!immediate) immediate = false;
        if(Midas.Smarty.runtimeCache[name]){
            callback(Midas.Smarty.runtimeCache[name]);
            return Midas.Smarty.runtimeCache[name];
        }
        var value = '';
        if(false){
            this.database.execute('SELECT * FROM templates where name = ?', { 
                values: [name], 
                onComplete: function(resultSet){ 
                    this.output('return');
                    while(row = resultSet.next()){ 
                        this.output('result');
                    } 
                }.bind(this), 
                onError: function(err){
                    this.output(err.message);
                    this.database.execute('CREATE TABLE IF NOT EXISTS templates (name TEXT NOT NULL PRIMARY KEY, template TEXT NOT NULL)', { 
                        values: [name], 
                        onComplete: function(resultSet){ 
                            this.output('created');
                        }
                    }); 
                }.bind(this)
            }); 
        }
        if(value == ''){
            var templateRequest = new Request({
                url: name+'?'+this.cacheID, 
                method: 'get', 
                //async: immediate,
                onSuccess: function(responseText, responseXML) {
                    Midas.Smarty.runtimeCache[name] = responseText;
                    if(callback) callback(this.response.text);
                }
            }).send();
        }
        this.value = value;
        if(false){
            this.database.execute('INSERT INTO templates (name, template) values(?, ?)', { 
                values: [name, this.value], 
                onComplete: function(resultSet){ 
                    this.output('insert');
                }
            }); 
        }
        return this.value;
    },
    parseMacro : function(macroText){
        var intext = false
        var textMarker = '';
        var result = {
            name : '',
            attrs :[]
        }
        var text = '';
        var name = '';
        invalue = false;
        first_tag = true;
        if(macroText.trim().startsWith('$')){
            result = {
                name : 'value',
                attrs :[]
            };
        }else{
            for(var lcv = 0; lcv < macroText.length; lcv++){
                ch = macroText.charAt(lcv);
                if(!first_tag){
                    if(intext){
                        if(ch === textMarker){
                            result.attrs.push({
                                name: name.trim(),
                                value: text
                            });
                            text = '';
                            intext = false;
                        }else{
                            text += ch;
                        }
                    }else{
                        switch(ch){
                            case '\'':
                            case '"':
                                if(!intext){
                                    intext = true;
                                    textMarker = ch;
                                }
                                break;
                            case ' ':
                                if(text != ''){
                                    result.attrs.push({
                                        name: name.trim(),
                                        value: text
                                    });
                                    text = '';
                                }
                                break;
                            case '=':
                                name = text;
                                text = '';
                                break;
                            default:
                                text += ch;
                        }
                    }
                }else{
                    if((ch === ' ' || macroText.length-1 == lcv) && text.trim() != ''){
                        first_tag = false;
                        if(ch !== ' ') text += ch;
                        result.name = text;
                        text = '';
                    }else{
                        if(ch.trim() != '') text += ch;
                    }
                }
            }
            result.attrs[name] = text;
        }
        if(text != ''){
            result.attrs.push({
                name: name,
                value: text
            });
            text = '';
        }
        return result;
    },
    nestBlocks : function(results, stack){
        //seperate blocks (single level > multi level)
        if(!results) return;
        if(stack == undefined) stack = [];
        var tag, last, blocks;
        results.copy().each(function(item, index){
            last = stack.getLast();
            tag = (last)?last.tag.name:undefined;
            blocks = (last)?last.blocks:results;
            if(!item.blocks) item.blocks = [];
            if(item.tag && this.blockTags.contains(item.tag.name)){
                stack.push(item);
            }
            if(tag && item.tag && '/'+tag == item.tag.name){
                this.nestBlocks(blocks.blocks, stack);
                stack.pop();
                blocks = (stack.getLast())?stack.getLast().blocks:results;
            }
            if(!blocks.contains(item)){
                blocks.push(item)
                results.erase(item);
            }
        }.bind(this));
    },
    fetch : function(templateName, callback, immediate){
        if(!immediate) immediate = false;
        var buffer = '';
        this.getTemplate(this.template_directory + templateName, function(template){
            var results = this.scan(template);
            //parse tags (single level)
            results.each(function(item, index){
                switch(item.blockType){
                    case 'tag':
                        item.tag = this.parseMacro(item.content);
                        break;
                }
            }.bind(this));
            this.nestBlocks(results);
            this.renderOutput(results);
            if(this.debug) this.output('['+templateName+']');
            buffer = Midas.SmartyLib.executeBlocks(results, this);
            if(callback) callback(buffer+'');
        }.bind(this), immediate);
        return buffer+'';
    },
    blockStack : [],
    blockTags : ['if', 'foreach'],
    parseTags : function(block_list){
        block_list.each(function(item, index){
            switch(item.blockType){
                case 'tag':
                    item.tag = this.parseMacro(item.content);
                    break;
            }
        }.bind(this));
    },
    renderOutput : function(block_list){ //any atomic node outputs it's value, node level parse
        //parse all the macros, do anything else we can
        block_list.each(function(item, index){
            switch(item.blockType){
                case 'tag':
                    //console.log('attempting render of tag '+item.tag.name);
                    if(item.tag.name == 'value'){
                        item.output = Midas.SmartyLib.evaluateSmartyPHPHybridExpression(item.content, this);
                        //console.log(['value:', item.content]);
                    }
                    if(item.blocks && item.blocks.length > 0){
                        this.renderOutput(item.blocks);
                    }
                    break;
                case 'text':
                    item.output = item.content;
                    break;
                case 'comment':
                    if(this.debug) item.output = '<!--[MSC] '+item.content+'-->';
                    break;
                default:
                    item.output = item.content;
                    break;
            }
        }.bind(this));
    },
    scan : function(template){
        var parts = [];
        var ch;
        var intag = false;
        var incomment = false;
        var instring = false;
        var stringtype = "'";
        var inliteral = false;
        //our current buffer is: parts[parts.length-1].content
        parts[0] = {
            blockType : 'text',
            content : ''
        };
        for(var lcv = 0; lcv < template.length; lcv++){
            ch = template.charAt(lcv);
            if(instring){
                    if(ch == stringtype && template.chatAt(lcv-1) != '\\'){ //are we closing the string?
                        instring = false;
                    }
                    parts[parts.length-1].content += ch;
            }else if(inliteral){
                if(ch == '{' && template.substring(lcv, lcv+10).toLowerCase() == '{/literal}'){ //we found a literal tag end
                    lcv += 9; //we need to eat the literal tag
                    parts[parts.length] = {
                        blockType : 'text',
                        content : ''
                    };
                    inliteral = false;
                }else{ //just another char on this tag
                    parts[parts.length-1].content += ch;
                }
            }else if(intag){
                if(incomment){
                    if(ch == '*'){ //we found a comment tag end
                        var count = 0
                        while(template.charAt(lcv+count+1) == ' ') count++;
                        if(template.charAt(lcv+count+1) == '}'){ //is the first non-whitespace char after the asterisk?
                            parts[parts.length] = {
                                blockType : 'text',
                                content : ''
                            };
                            lcv += count+1
                            intag = false;
                            incomment = false;
                        }else{
                            parts[parts.length-1].content += ch;
                        }
                    }else{ //just another char on this tag
                        parts[parts.length-1].content += ch;
                    }
                }else{
                    if(ch == '}'){ //we found a tag end
                        parts[parts.length] = {
                            blockType : 'text',
                            content : ''
                        };
                        intag = false;
                    }else{ //just another char on this tag
                        parts[parts.length-1].content += ch;
                    }
                }
            }else{ // we're not in a tag or a string!
                if(ch == '{'){ //we found a tag start
                    if(template.substring(lcv, lcv+9).toLowerCase() == '{literal}'){
                        lcv += 8; //we need to eat the literal tag
                        parts[parts.length] = {
                            blockType : 'literal',
                            content : ''
                        };
                        inliteral = true;
                    }else{
                        if(template.charAt(lcv+1) == '*'){ //starting a new smarty comment
                            parts[parts.length] = {
                                blockType : 'comment',
                                content : ''
                            };
                            lcv++;
                            intag = true;
                            incomment=true;
                        }else{ //starting a new smarty tag
                            parts[parts.length] = {
                                blockType : 'tag',
                                content : ''
                            };
                            intag = true;
                        }
                    }
                }else{ //we think this must just be a normal char
                    parts[parts.length-1].content += ch;
                }
            }
        }
        return parts;
    }
});

Midas.SmartyLib = {
    conditions : [],
    pad : function(number, length) {
        var str = '' + number;
        while (str.length < length) {
            str = '0' + str;
        }
        return str;
    },
    evaluateSmartyPHPHybridBooleanExpression : function(expression, smartyInstance){
        //var pattern = /[Ii][Ff] +(\$[A-Za-z][A-Za-z0-9.]*) *$/s;
        expression = expression.trim();
        if(expression.toLowerCase().substring(0, 2) == 'if'){
            //todo: multilevel
            expression = expression.substring(2).trim();
            var expressions = expression.split('&&');
            var value = true;
            expressions.each(function(exp){
                value = value && Midas.SmartyLib.evaluateSmartyPHPHybridBooleanExpression(exp, smartyInstance);
            });
            return value;
        }else{
            pattern = new RegExp('(.*)( eq| ne| gt| lt| ge| le|==|>=|<=|<|>)(.*)', 'm');
            parts = expression.match(pattern);
            if(parts && parts.length > 3){
                var varOne = Midas.SmartyLib.evaluateSmartyPHPHybridVariable(parts[1].trim(), smartyInstance);
                var varTwo = Midas.SmartyLib.evaluateSmartyPHPHybridVariable(parts[3].trim(), smartyInstance);
                var res;
                switch(parts[2]){
                    case '==':
                    case 'eq':
                        res = (varOne == varTwo);
                        break;
                    case '!=':
                    case 'ne':
                        res = (varOne != varTwo);
                        break;
                    case '>':
                    case 'gt':
                        res = (varOne > varTwo);
                        break;
                    case '<':
                    case 'lt':
                        res = (varOne < varTwo);
                        break;
                    case '<=':
                    case 'le':
                        res = (varOne <= varTwo);
                        break;
                    case '>=':
                    case 'ge':
                        res = (varOne >= varTwo);
                        break;
                }
                return res;
            }else{
                var res;
                if( (expression - 0) == expression && expression.length > 0){ //isNumeric?
                    res = eval(expression);
                    res = res == 0;
                }else if(expression == 'true' || expression == 'false'){ //boolean
                    res = eval(expression);
                }else{
                    res = Midas.SmartyLib.evaluateSmartyPHPHybridVariable(expression, smartyInstance);
                    res = (res != null && res != undefined && res != '' && res != false);
                }
                return res;
            }
        }
    },
    evaluateSmartyPHPHybridExpression : function(variableName, smartyInstance){ // this decodes a value that may be modified by functions using the '|' separator
        if(variableName === undefined) return null;
        var methods = variableName.splitHonoringQuotes('|', ['#']);
        methods.reverse();
        //console.log(['expression-methods:', methods]);
        var accessor = methods.pop();
        var value = Midas.SmartyLib.evaluateSmartyPHPHybridVariable(accessor, smartyInstance);
        //now that we have the value, we must run it through the function stack we found
        var method;
        var params;
        var old = value;
        methods.each(function(item, index){
            params = item.split(':');
            params.reverse();
            //console.log(['expression-item:', item]);
            method = params.pop(); //1st element is
            if(method == 'default'){
                if(!value || value == '') value = Midas.SmartyLib.evaluateSmartyPHPHybridVariable(params[0], smartyInstance);
            }else{
                value = Midas.SmartyLib.executeMethod(method, value, params);
            }
        });
        return value;
    },
    evaluateSmartyPHPHybridVariable : function(accessor, smartyInstance, isConf){
        if(isConf == 'undefined' || isConf == null) isConf = false;
        if(!accessor) return '';
        if(accessor.toLowerCase().startsWith('\'') && accessor.toLowerCase().endsWith('\'')) return accessor.substr(1, accessor.length-2);
        if(accessor.toLowerCase().startsWith('"') && accessor.toLowerCase().endsWith('"')) return accessor.substr(1, accessor.length-2);
        if(accessor.toLowerCase().startsWith('$smarty.')) return smartyInstance.get(accessor.substr(8));
        if(accessor.startsWith('$')){
            var acc = accessor.substring(1);
            return smartyInstance.get(acc);
        }
        if(accessor.startsWith('#') && accessor.endsWith('#')){
            var cnf = accessor.substr(1, accessor.length-2);
            return Midas.SmartyLib.evaluateSmartyPHPHybridVariable( cnf , smartyInstance, true);
        }
        return smartyInstance.get(accessor);
        var parts = accessor.split('.');
        parts.reverse();
        var currentPart = parts.pop();
        var currentValue;
        if(isConf){
            return smartyInstance.getConf(accessor);
            currentValue = smartyInstance.config[currentPart];
        }else switch(currentPart){
            case 'smarty':
                currentValue = smartyInstance.internal;
                break;
            default:
                currentValue = smartyInstance.get(currentPart);
                if(currentValue == 'undefined' ) currentValue = '';
        }
        parts.each(function(item, index){
            if(!currentValue && currentValue !== 0) return;
            if(currentValue[item] == 'undefined'){
                currentValue = null;
            }else{
                currentValue = currentValue[item];
            }
        });
        return currentValue;
    },
    executeMethod : function(name, value, params){
        if(window[name] && typeOf(window[name]) == 'function') return window[name].apply(this, params);
        switch(name){
            case 'default':
                if(value == null || value == ''){
                    var p = params.pop();
                    return p;
                }else{
                    return value;
                }
                break;
            case 'truncate':
                var width = params[0]?Number.from(params[0]):80;
                var trailer = params[1]?params[1]:'...';
                //var fullWords = params[3] && (params[3].toLowerCase() == 't' || params[3].toLowerCase() == 'true')?true:false;
                //var truncateInMiddle = = params[4] && (params[4].toLowerCase() == 't' || params[4].toLowerCase() == 'true')?true:false;
                return width < value.length ? value.substr(0, width)+trailer:value;
            default:
                //alert('|'+name+'||'+params.pop()+'|');
        }
    },
    conditionalBranch : function(conditional, truebranch, falsebranch){
        if(!conditions[conditional]){
            conditions[conditional] = convertConditionToJS(conditional);
        }
        eval('var result = '+conditions[conditional]+';');
        //todo: branch caching as a function
        if(result){
            eval(truebranch);
        }else{
            eval(falsebranch);
        }
    },
    convertConditionToJS: function(conditional){
        
    },
    ifMacro: function(panelName, attributes, smartyInstance, block){
        var result = Midas.SmartyLib.evaluateSmartyPHPHybridBooleanExpression(block.content, smartyInstance);
        //console.log(['if', block.content, result])
        //prescan to make sure the else branch is there
        var hitElse = false;
        var item;
        if(block.ifBlocks) block.ifBlocks.empty();
        if(block.elseBlocks) block.elseBlocks.empty();
        for(index in block.blocks){
            item = block.blocks[index];
            if(item.blockType == 'tag' && item.content.trim() == 'else'){
                hitElse = true;
            }else if(hitElse){
                if(!block.elseBlocks) block.elseBlocks = [];
                block.elseBlocks.push(item);
            }else{
                if(!block.ifBlocks) block.ifBlocks = [];
                block.ifBlocks.push(item);
            }
        }
        var buffer = '';
        //do the actual rendering
        if(result) buffer = Midas.SmartyLib.executeBlocks(block.ifBlocks, smartyInstance);
        else buffer = Midas.SmartyLib.executeBlocks(block.elseBlocks, smartyInstance);
        if(buffer == undefined) return '';
        return buffer;
    },
    generateUUID: function(){
        var s = [];
        var hexDigits = "0123456789ABCDEF";
        for (var i = 0; i < 32; i++)  s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
        s[12] = "4";  // bits 12-15 of the time_hi_and_version field to 0010
        s[16] = hexDigits.substr((s[16] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
        var uuid = s.join("");
        return uuid;
    },
    executeBlocks: function(blocks, smartyInstance){
        var buffer = '';
        var out = {};
        var count = 1;
        if(!blocks || typeof(blocks) != 'object'){
            if(smartyInstance.debug) smartyInstance.output('No blocks to execute!');
            return;
        }
        var ins = this.generateUUID();
        var count = 0;
        blocks.each(function(item, index){
            if(typeOf(item) != 'object') return;
            //console.log(['block-X['+item.blockType+']', item.content]);
            //console.log(['block-X['+ins+':'+(count++)+']', item, blocks, buffer]);
            if(item.tag){
                buffer += smartyInstance.macro(item.tag.name, item.tag.attrs, item);
            }else if(item.output){
                buffer += item.output;
            }
        }.bind(this));
        return buffer;
    },
    forMacro: function(tag, smartyInstance, block){
        var requiredAttrs = ['from', 'item'];
        var buffer = '';
        if(this.requireAttrs(tag, requiredAttrs, smartyInstance)){
            var name;
            var indexName;
            if(tag.attrs.name){
                name = this.getAttr('name', tag.attrs);
                indexName = 'foreach.'+name+'.index';
            }else{ //assign a random ID for this loop variable
                name = 'A'+this.generateUUID(); //begins with a var
                indexName = 'foreach.'+name+'.index';
            }
            var from = this.getAttr('from', tag.attrs);
            var to = this.getAttr('to', tag.attrs);
            var keyName = this.getAttr('key', tag.attrs);
            if(!keyName) keyName = '__loop_key';
            var itemName = this.getAttr('item', tag.attrs);
            var collection = Midas.SmartyLib.evaluateSmartyPHPHybridVariable(from, smartyInstance);
            var collection_length = 0;
            var keys = [];
            for(index in collection){
                collection_length++;
                keys.push(index);
            }
            var count = 0;
            if(collection_length > 0){
                var indexName = 'foreach.'+name+'.index';
                if(typeof(collection) == 'string' && collection == ''){
                    return buffer;
                }
                var originalIndex = smartyInstance.get(indexName);
                var originalKey = smartyInstance.set(keyName);
                var originalItem = smartyInstance.set(itemName);
                if(collection.each){ //it's an array;
                    collection.each(function(item, index){ //handles continue
                        smartyInstance.set(indexName, count++);
                        smartyInstance.set(keyName, index);
                        smartyInstance.set(itemName, item);
                        buffer += Midas.SmartyLib.executeBlocks(this.blocks, smartyInstance);
                    }.bind(block));
                }else{ //let's hope this is an object
                    var item;
                    for(var index in collection){
                        item = collection[index];
                        smartyInstance.set(indexName, count);
                        smartyInstance.set(keyName, index);
                        smartyInstance.set(itemName, item);
                        //smartyInstance.output('x');
                        buffer += Midas.SmartyLib.executeBlocks(block.blocks, smartyInstance);
                        //count++;
                    }
                }
                smartyInstance.set(indexName, null);
                smartyInstance.set(keyName, null);
                smartyInstance.set(itemName, null);
            }else{
                smartyInstance.output('ERROR: empty collection('+from+')!');
                smartyInstance.output(collection);
                smartyInstance.output('environment:');
                smartyInstance.output(smartyInstance.environment);
            }
        }else{
            smartyInstance.output('missing a required attr! '+requiredAttrs);
            smartyInstance.output(tag.attrs);
        }
        return buffer;
    },
    requireAttrs: function(tag, attrs, smarty){
        var returnVal = true;
        var foundOne;
        var out;
        attrs.each(function(attr, aIndex){
            foundOne = false;
            out = '';
            tag.attrs.each(function(tagAttr, taIndex){
                if(attr == tagAttr.name){
                    foundOne = true;
                }
            });
            returnVal = returnVal && foundOne;
        });
        return returnVal;
    },
    getAttr: function(tag, attrs){
        var returnVal = null;
        attrs.each(function(attr, aIndex){
            if(tag == attr.name) returnVal = attr.value;
        });
        return returnVal;
    },
    output : function(value){
        if(console) {
            if(navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1) {
                //console.log(value);
            } else {
                //console.log.apply(this,arguments);
            }
        }
    },
    getValue : function(expression){
        var parts = explode('|', expression);
        var value = parts[0].substring(1); // omit the '$'
        for(var lcv = 1; lcv < parts.length; lcv++){
            eval('value = '+parts[lcv]+'(value);');
        }
        //console.log(['getval', expression, value]);
        return value;
    }
};
Midas.Smarty.runtimeCache = {};

var XHTMLParser = new Class({
    Extends : Midas.SAXParser,
    stack : [],
    root : null,
    scripts : [],
    open : function(name, attrs){
        var node;
        if(name.indexOf(':') != -1){ //if this is one of FB's tags, we need to use innerHTML to get the correct tagName back out
            var attributes = '';
            for(key in attrs){
                attributes += key + '="'+attrs[key]+'" ';
            }
            node = new Element('div');
            node.innerHTML = '<'+name+' '+attributes+'></'+name+'>';
            node = node.children[0];
        }else{
            node = new Element(name, attrs);
        }
        if(this.stack.length > 0) this.stack.getLast().appendChild(node);
        this.stack.push(node);
    },
    content : function(text){
        if(this.stack.length > 0) this.stack.getLast().appendText(text);
    },
    close : function(name){
        //this.root = this.stack[0];
        this.root = this.stack.pop();
        //if(this.root.tagName.toLowerCase() != name.toLowerCase()) throw(this.root.tagName+' != '+name);
        if(name.toLowerCase() == 'script') this.scripts.push();
    },
    parse : function(html){
        //wrap the script tag bodies with CDATA tags so our strict parser won't freak out
        var exp = new RegExp('(<script\\b[^>]*>)([\\s\\S]*?)(<\\/script>)', 'igm');
        html = html.replace(exp, '$1/*<![CDATA[*//*---->*/$2/*--*//*]]>*/$3');
        this.parent('<xml>'+html+'</xml>');
        var result = this.root.getChildren();
        //don't ask
        if(result[0] && result[0].tagName.toLowerCase() == 'html') return result[0];
        if(this.stack[1]) return this.stack[1];
        return this.root.getChildren();
    }
});/*
---
description: An extensible Mootools object container bridging to a pureJS SAX parser

license: [MIT-style, LGPL]

authors:
- Abbey Hawk Sparrow

requires:
    core/1.2.4: '*'

provides: [Midas.XMLParser]
...
*/
if(!Midas) var Midas = {};
Midas.TagParser = new Class({ //my ultra-slim tag parser
    strict : true,
    opener : '<',
    closer : '>',
    attributeAssign : '=',
    attributeDelimiters : ['"'],
    closeEscape : '/',
    allowUndelimitedAttributes : false,
    literalTags : [],
    unaryTags : [],
    specialTags : {},
    initialize: function(options){
        Object.each(options, function(option, name){
            this[name] = option;
        });
        if(typeOf(this.literalTags) == 'string') this.literalTags = this.literalTags.split(',')
        if(typeOf(this.attributeDelimiters) == 'string') this.attributeDelimiters = this.attributeDelimiters.split(',')
    },
    open: function(tagName, attributes){
        sys.puts('open:'+tagName.toLowerCase());
    },
    content: function(text){
        sys.puts('con:'+text);
    },
    close: function(tagName){
        sys.puts('close:'+tagName.toLowerCase());
    },
    error: function(exception){
        sys.puts(exception);
    },
    parse: function(xmlChars){
        var tagOpen = false;
        var currentTag = '';
        var content = '';
        var ch;
        var tagStack = [];
        var literalMode = false;
        var strictError = 'Strict parse error: Unmatched Tag!';
        for(var lcv = 0; lcv < xmlChars.length; lcv++){
            ch = String.fromCharCode(xmlChars[lcv]);
            if(tagOpen){
                if(ch == this.closer){
                    var tag = this.parseTag(currentTag);
                    if(tag.name[0] == this.closeEscape){
                        tag.name = tag.name.substring(1);
                        this.close(tag);
                        var lastTag = tagStack.pop();
                        if(this.strict && lastTag.name != tag.name){
                            this.error(strictError+' ['+lastTag.name+']');
                            return;   
                        }
                        literalMode = this.literalTags.contains(tagStack[tagStack.length-1]);
                    }else{
                        this.open(tag);
                        tagStack.push(tag);
                        literalMode = this.literalTags.contains(tagStack[tagStack.length-1]);
                        if(currentTag[currentTag.length-1] == this.closeEscape || this.unaryTags.contains(tag.name)){
                            this.close(tag);
                            var lastTag = tagStack.pop();
                            if(this.strict && lastTag.name != tag.name){
                                this.error(strictError+' ['+lastTag.name+']');
                                return;
                            }
                            literalMode = this.literalTags.contains(tagStack[tagStack.length-1]);
                        }
                    }
                    tagOpen = false;
                }else currentTag += ch;
            }else{
                if(!literalMode && ch == this.opener){
                    currentTag = '';
                    tagOpen = true;
                    if(content.trim() != '') this.content(content.trim());
                    content = '';
                }else content += ch;
            }
        }
        if(content.trim() != '') this.content(content.trim());
    },
    parseTag: function(tag){
        var ch;
        var currentValue = '';
        var tagName = false;
        var attributeName = false;
        var inQuote = false;
        var attributes = {};
        for(var lcv = 0; lcv < tag.length; lcv++){
            ch = tag[lcv];
            if(tagName){
                var endedQuote = false;
                if(inQuote){
                    if(inQuote == ch){ //end of quote
                        inQuote = false;
                        endedQuote = true;
                    }else{
                        currentValue += ch;
                        continue;
                    }
                }else{
                    if(this.attributeDelimiters.contains(ch)){
                        inQuote = ch;
                        continue;
                    }
                }
                if(attributeName){
                    if(ch == ' ' || endedQuote){
                        attributes[attributeName.trim()] = currentValue;
                        attributeName = false;
                        currentValue = '';
                    }else currentValue += ch;
                }else{
                    if(ch == this.attributeAssign){
                        attributeName = currentValue;
                        currentValue = '';
                    }else currentValue += ch;
                }
                this.attributeDelimiters.contains(ch)
            }else{
                if(ch == ' '){
                    tagName = currentValue;
                    currentValue = '';
                }else currentValue += ch;
            }
        }
        if(attributeName && currentValue != ''){
            attributes[attributeName.trim()] = currentValue;
        }
        if(!tagName) tagName = currentValue;
        return {
            name: tagName,
            attributes: attributes
        };
    }
});


Midas.HTMLParser = new Class({
    Extends : Midas.TagParser,
    root : null,
    nodeStack : [],
    initialize: function(){
        this.parent({
            strict : true,
            opener : '<',
            closer : '>',
            attributeAssign : '=',
            attributeDelimiters : ['"', "'"],
            closeEscape : '/',
            allowUndelimitedAttributes : false,
            literalTags : ['script'],
            unaryTags : ['br', 'hr', 'img']
        });
        this.root = new Element('root');
        this.  nodeStack.push(this.root);
    },
    open: function(tagName, attributes){
        var element = new Element(tagName, attributes);
        this.nodeStack.getLast().appendChild(element);
        this.nodeStack.push(element);
    },
    content: function(text){
        this.nodeStack.getLast().appendText(text);
    },
    close: function(tagName){
        this.nodeStack.pop(element);
    }
});
Midas.SmartyParser = new Class({
    Extends : Midas.TagParser,
    initialize: function(){
        this.parent({
            strict : true,
            opener : '{',
            closer : '{',
            attributeAssign : '=',
            attributeDelimiters : ['"', "'"],
            closeEscape : '/',
            allowUndelimitedAttributes : true,
            literalTags : ['literal'],
            specialTags : {
                'if':function(text){
                    
                },
                'for':function(text){
                
                }
            }
        });
    }
}); 
this.Midas = Midas;
})(); //this.Midas = Midas;
if (typeof exports != 'undefined') (function(){
    for (var key in this) if (!GLOBAL_ITEMS.contains(key)){
        exports[key] = this[key];
    }
    exports.apply = function(object){
        Object.append(object, exports);
    };
})();

