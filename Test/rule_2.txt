// Compute employee attributes from Bargaining Units
var employeesByJob = employees.byGroup('job');
bargaining_units.forEach(function(unit){
    var myBU = employeesByJob[unit.job];
	if(!myBU) emit('warning', 'no employees found for \''+ unit.job+'\'!', unit);
    else myBU.forEach(function(employee, innn){
        employee.years_worked = ( current_year - (new Date(employee.start_date)).getFullYear() ) || 0;
        employee.start_step = employee.start_step?employee.start_step:1;
	    employee.step = Math.max(Math.min(employee.start_step+employee.years_worked, 5), 1);
	    employee.base_salary = unit['step_'+employee.step];
	    employee.total_cost = employee.base_salary;
    }.bind(this));
});

//zero new columns (hack to show column headers)
budget.forEach(function(item){
	item.rule_based = false;
    item.jobs = '';
})

// Compute budget employee totals
current_budget.clone().with('ledger_description','Salaries & Benefits').forEach(function(benefitsLineItem){
    var total = 0;
    var count = 0;
    employees.clone().with('department', benefitsLineItem.department).with('division', benefitsLineItem.division).forEach(function(employee){
        total += employee.total_cost;
        if(!benefitsLineItem.jobs) benefitsLineItem.jobs = employee.job;
        else{
            var items = benefitsLineItem.jobs.split(',');
            if( items.indexOf(employee.job) === -1 ) benefitsLineItem.jobs += ','+employee.job;
        }
      count++;
    });
    if(count > 0){
        benefitsLineItem.amount = total;
        benefitsLineItem.rule_based = true;
    }else{
        benefitsLineItem.rule_based = false;
        if(benefitsLineItem.amount > 0) emit('warning', 'there are no employees associated with salaries and benefits($'+benefitsLineItem.amount+') from '+benefitsLineItem.department+'/'+benefitsLineItem.division+'!')
    }
});

// Ensure this budget is within 20% of last year
var thisTotalBudgetExpenses = sum(current_budget.with("ledger_type", "Expense"), "amount");
var previousTotalBudgetExpenses = sum(budget.with("year", current_year-1).with("ledger_type", "Expense"), "amount");
ensure((thisTotalBudgetExpenses-previousTotalBudgetExpenses)/previousTotalBudgetExpenses, "<", 0.20);